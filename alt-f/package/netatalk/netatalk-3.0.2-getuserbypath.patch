--- netatalk-3.0.2/libatalk/util/netatalk_conf.c-orig	2013-02-05 16:27:00.990047559 +0000
+++ netatalk-3.0.2/libatalk/util/netatalk_conf.c	2013-02-06 17:21:51.229725725 +0000
@@ -1432,6 +1432,54 @@
     return( vol );
 }
 
+/*
+ * get username by path
+ * 
+ * getvolbypath() assumes that the user home directory has the same name as the username.
+ * If that is not true, getuserbypath() is called and tries to retrieve the username
+ * from the directory owner, checking its validity.
+ * 
+ * @param   path (r) absolute volume path
+ * @returns NULL     if no match is found, pointer to username if successfull
+ *
+ */ 
+char *getuserbypath(const char *path)
+{
+    struct stat sbuf;
+    struct passwd  *pwd;
+    char *hdir;
+
+    LOG(log_debug, logtype_afpd, "getuserbypath(\"%s\")", path);
+
+    /* does folder exists? */
+    if (stat(path, &sbuf) != 0)
+        return NULL;
+
+    /* get uid of dir owner */
+    if ((pwd = getpwuid(sbuf.st_uid)) == NULL)
+        return NULL;
+
+    /* does user home directory exists? */
+    if (stat(pwd->pw_dir, &sbuf) != 0)
+        return NULL;
+
+    /* resolve and remove symlinks */
+    if ((hdir = realpath(pwd->pw_dir, NULL)) == NULL) 
+        return NULL;
+
+    /* handle subdirectories, path = */
+    if (strncmp(path, hdir, strlen(hdir)) != 0) {
+        free(hdir);
+        return NULL;
+    }
+
+    LOG(log_debug, logtype_afpd, "getuserbypath: match user: %s, home: %s, realhome: %s",
+        pwd->pw_name, pwd->pw_dir, hdir);
+
+    free(hdir);
+    return pwd->pw_name;
+}
+
 /*!
  * Search volume by path, creating user home vols as necessary
  *
@@ -1539,6 +1587,13 @@
         subpath = prw;
 
     strlcat(tmpbuf, user, MAXPATHLEN);
+    if (getpwnam(user) == NULL) {
+        char *tuser;
+        if ((tuser = getuserbypath(tmpbuf)) != NULL) {
+            free(user);
+            user = strdup(tuser);
+        }
+    }
     strlcpy(obj->username, user, MAXUSERLEN);
     strlcat(tmpbuf, "/", MAXPATHLEN);
 
