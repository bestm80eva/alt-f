--- dns323-reloaded-0.7.167-orig/reboot.S	2007-06-13 22:56:34.000000000 +0100
+++ dns323-reloaded-0.7.167/reboot.S	2011-03-22 19:43:58.178489073 +0000
@@ -64,7 +64,7 @@
 @        mov     pc, lr
 
         /* copy initrd */
-        mov     r2, #0x800000
+        mov     r2, #0x600000 /* putterboy says it succeeds often this way */
         adr     r3, dns323_initrd_segments
 copy_initrd_next_segment:
         ldmia   r3!, {r1}          @ r1 = ptr
--- dns323-reloaded-0.7.167-orig/main.c	2007-06-13 22:59:00.000000000 +0100
+++ dns323-reloaded-0.7.167/main.c	2011-03-22 19:39:31.247614460 +0000
@@ -38,20 +38,21 @@
 module_param(machtype, int, 0);
 MODULE_PARM_DESC(machtype, "Machine type (see linux/arch/arm/tools/mach-types)");
 
-
-
 /* reboot.S */
 /* current array sizes:
    200 for kernel
    280 for initrd
 
-   mean segment size is 32k,
+   mean segment size is 32k, jc: how was "mean" determined? max segment has 131KB
    two longs needed per segment
 
    kernel < 200/2 * 32k = 3.2M
    initrd < 280/2 * 32k = 4.3M
 */
-   
+
+#define KERN_SLOTS 200
+#define INITRD_SLOTS 280
+
 extern unsigned long dns323_kernel_segments[];
 extern unsigned long dns323_initrd_segments[];
 extern unsigned long dns323_taglist;
@@ -62,162 +63,172 @@
 extern unsigned long dns323_reboot_size;
 extern unsigned long dns323_reboot_start;
 
-
 /* reserve low 16MB */
 #define MIN_ADDR 0x01000000lu
 
 /* */
-#define SEGMENT_SIZE (32*PAGE_SIZE)
+#define SEGMENT_SIZE (32*PAGE_SIZE) /* jc: 32*4096=131KB */
 #define MIN_SEGMENT_SIZE PAGE_SIZE
 static unsigned int segment_size = SEGMENT_SIZE;
 
-static void load_file(char *filename, int count, unsigned long *segments)
-{
-        mm_segment_t old_fs = get_fs();
-        int fd, i;
-
-        void *ptr;
-        unsigned long c = 0;
+static int dns323_fail(char *msg) {
+  printk(msg);
+  return -1;
+}
 
-        int segc = 0;
+static int load_file(char *filename, int count, unsigned long *segments, int slots)
+{
+  mm_segment_t old_fs = get_fs();
+  int fd, i;
 
-        set_fs(KERNEL_DS);
-        if ((fd = sys_open(filename, O_RDONLY, 0)) < 0) 
-                panic("%s: open failed (%d)\n", filename, fd);
-        while (c < count) {
-
-        retry:
-                while (!(ptr = kmalloc(segment_size, GFP_KERNEL))) {
-                        if (segment_size == MIN_SEGMENT_SIZE)
-                                panic("load_file: Out of memory\n");
-                        segment_size >>= 1;
-                }
-                if (virt_to_phys(ptr) < MIN_ADDR) {
-                        printk("not using %d bytes reserved memory at %p / %p\n", segment_size, ptr, __virt_to_phys(ptr));
-                        goto retry;
-                }
-
-                i = sys_read(fd, ptr, segment_size);
-                printk("loaded %d of %d bytes at %p / %p\n", i, count, ptr, __virt_to_phys(ptr));
-                if (i > 0) {
-                        *segments++ = virt_to_phys(ptr);
-                        *segments++ = (unsigned long)i;
-                        c += i;
-                        segc++;
-                }
-                if (i < 0)
-                        panic("load_file: read error\n");
-        }
-        *segments = 0;
-        sys_close(fd);
-        printk("%s: OK (%d segments)\n", filename, segc);
-        set_fs(old_fs);
+  void *ptr;
+  
+  unsigned long c = 0;
+
+  int segc = 0;
+
+  set_fs(KERNEL_DS);
+  if ((fd = sys_open(filename, O_RDONLY, 0)) < 0) 
+	return dns323_fail("file open failed\n");
+  while (c < count) {
+
+  retry:
+	while (!(ptr = kmalloc(segment_size, GFP_KERNEL))) {
+	  if (segment_size == MIN_SEGMENT_SIZE)
+		return dns323_fail("allocating segments: out of memory\n");
+	  printk("requested %u segment unavailable\n", segment_size);
+	  segment_size >>= 1;
+	}
+	if (virt_to_phys(ptr) < MIN_ADDR) {
+	  printk("not using %d bytes reserved memory at %p / %p\n", segment_size, ptr, __virt_to_phys(ptr));
+	  goto retry;
+	}
+
+	i = sys_read(fd, ptr, segment_size);
+	printk("loaded %d of %d bytes at %p / %p\n", i, count, ptr, __virt_to_phys(ptr));
+	if (i > 0) {
+	  *segments++ = virt_to_phys(ptr);
+	  *segments++ = (unsigned long)i;
+	  c += i;
+	  segc++;
+	  if (segc >= slots)
+		  return dns323_fail("segments array exausted.\n");
+	}
+	if (i < 0)
+	  return dns323_fail("file read error\n");
+  }
+  // *segments = 0; jc: segments array is initialized with zeros, don't take the chance to overwrite anything  over the end
+  sys_close(fd);
+  printk("****** %s loaded OK (%d segments)\n", filename, segc);
+  set_fs(old_fs);
+  return 0;
 }
 
-
 static void *make_taglist(int initrd_size) 
 {
-        void *taglist;
-        struct tag *t;
-        int i;
-        unsigned long mem_start = 0;
-        unsigned long mem_size = (unsigned long)__virt_to_phys(high_memory);
-
-        if (!(t = taglist = kmalloc(MIN_SEGMENT_SIZE, GFP_KERNEL)))
-                panic("make_taglist: Out of memory\n");
-
-        t->hdr.tag = ATAG_CORE;
-        t->hdr.size = tag_size(tag_core);
-        t->u.core.flags = 1;
-        t->u.core.pagesize = PAGE_SIZE;
-        t->u.core.rootdev = 0x0; //0x00010000lu;
-
-        printk("CMDLINE: %s\n", cmdline);
-        t = tag_next(t);
-        i = strlen(cmdline)+1;
-        t->hdr.size = (sizeof(struct tag_header) + i+3) >> 2;
-        t->hdr.tag = ATAG_CMDLINE;
-        strcpy(t->u.cmdline.cmdline, cmdline);
-
-        printk("MEM: start %08lx size %luMB\n", mem_start, mem_size >> 20);
-        t = tag_next(t);
-        t->hdr.size = tag_size(tag_mem32);
-        t->hdr.tag = ATAG_MEM;
-        t->u.mem.size = mem_size;
-        t->u.mem.start = mem_start;
-
-        if (initrd_size > 0) {
-                printk("INITRD: start %08lx size %d\n", 0x800000lu, initrd_size);
-                t = tag_next(t);
-                t->hdr.size = tag_size(tag_initrd);
-                t->hdr.tag = ATAG_INITRD2;
-                t->u.initrd.start = 0x800000;
-                t->u.initrd.size = initrd_size;
-        }
-
-        t = tag_next(t);
-        t->hdr.size = 0;
-        t->hdr.tag = ATAG_NONE;
+  void *taglist;
+  struct tag *t;
+  int i;
+  unsigned long mem_start = 0;
+  unsigned long mem_size = (unsigned long)__virt_to_phys(high_memory);
+
+  if (!(t = taglist = kmalloc(MIN_SEGMENT_SIZE, GFP_KERNEL)))
+	dns323_fail("make_taglist: Out of memory\n");
+
+  t->hdr.tag = ATAG_CORE;
+  t->hdr.size = tag_size(tag_core);
+  t->u.core.flags = 1;
+  t->u.core.pagesize = PAGE_SIZE;
+  t->u.core.rootdev = 0x0; //0x00010000lu;
+
+  printk("CMDLINE: %s\n", cmdline);
+  t = tag_next(t);
+  i = strlen(cmdline)+1;
+  t->hdr.size = (sizeof(struct tag_header) + i+3) >> 2;
+  t->hdr.tag = ATAG_CMDLINE;
+  strcpy(t->u.cmdline.cmdline, cmdline);
+
+  printk("MEM: start %08lx size %luMB\n", mem_start, mem_size >> 20);
+  t = tag_next(t);
+  t->hdr.size = tag_size(tag_mem32);
+  t->hdr.tag = ATAG_MEM;
+  t->u.mem.size = mem_size;
+  t->u.mem.start = mem_start;
+
+  if (initrd_size > 0) {
+	printk("INITRD: start %08lx size %d\n", 0x800000lu, initrd_size);
+	t = tag_next(t);
+	t->hdr.size = tag_size(tag_initrd);
+	t->hdr.tag = ATAG_INITRD2;
+	t->u.initrd.start = 0x600000; // putterboy says reloading succeeds often this way
+	t->u.initrd.size = initrd_size;
+  }
+
+  t = tag_next(t);
+  t->hdr.size = 0;
+  t->hdr.tag = ATAG_NONE;
 
-        return taglist;
+  return taglist;
 }
 
 /* main function */
 static int __init reloaded_init(void)
 {
-        mm_segment_t old_fs;
-        int err = 0;
-        struct kstat kernel_st;
-        struct kstat initrd_st;
-        void *dns323_reboot_code;
-
-        printk("reloaded for DNS-323, 2007 tp@fonz.de\n");
-
-        /* load kernel and initrd */
-        old_fs = get_fs();
-        set_fs(KERNEL_DS);
-        if ((err = vfs_stat(kernel, &kernel_st)) < 0) 
-                printk("%s: stat failed (%d)\n", kernel, err);
-        else if (*initrd && (err = vfs_stat(initrd, &initrd_st)) < 0)
-                printk("%s: stat failed (%d)\n", initrd, err);
-        set_fs(old_fs);
-        if (err < 0)
-                return -1;
-
-        printk("%s: %lld bytes\n", kernel, kernel_st.size);
-        load_file(kernel, kernel_st.size, dns323_kernel_segments);
-        if (*initrd) {
-                printk("%s: %lld bytes\n", initrd, initrd_st.size);
-                load_file(initrd, initrd_st.size, dns323_initrd_segments);
-        }
-
-        /* */
-        dns323_machtype = machtype;
-        printk("dns323_machtype = %ld\n", dns323_machtype);
-        dns323_taglist = virt_to_phys(make_taglist(*initrd ? initrd_st.size : 0));
-        printk("dns323_taglist  = %lx (%p)\n", dns323_taglist, phys_to_virt(dns323_taglist));
-        if (!(dns323_reboot_code = kmalloc(dns323_reboot_size, GFP_KERNEL))) 
-                panic("reboot code: Out of memory\n");
-        printk("copying %lu bytes reboot code from %p to %p\n",
-               dns323_reboot_size, dns323_do_reboot, dns323_reboot_code);
-        memcpy(dns323_reboot_code, dns323_do_reboot, dns323_reboot_size);
-        dns323_reboot_start = virt_to_phys(dns323_reboot_code);
-        printk("dns323_reboot_start  = %lx\n", dns323_reboot_start);
-
-        /* go */
-        printk(KERN_INFO "Reloading...\n");
-        flush_icache_range((unsigned long)dns323_reboot_code, (unsigned long)dns323_reboot_code + dns323_reboot_size);
-        cpu_proc_fin();
-        setup_mm_for_reboot(0);
-        dns323_reboot();
+  mm_segment_t old_fs;
+  int err = 0;
+  struct kstat kernel_st;
+  struct kstat initrd_st;
+  void *dns323_reboot_code;
+
+  printk("reloaded for DNS-323, 2007 tp@fonz.de\n");
+  
+  /* load kernel and initrd */
+  old_fs = get_fs();
+  set_fs(KERNEL_DS);
+  if ((err = vfs_stat(kernel, &kernel_st)) < 0) 
+	printk("%s: stat failed (%d)\n", kernel, err);
+  else if (*initrd && (err = vfs_stat(initrd, &initrd_st)) < 0)
+	printk("%s: stat failed (%d)\n", initrd, err);
+  set_fs(old_fs);
+  if (err < 0)
+	return -1;
+
+  printk("%s: %lld bytes\n", kernel, kernel_st.size);
+  if (load_file(kernel, kernel_st.size, dns323_kernel_segments, KERN_SLOTS))
+	  return -1;
+  if (*initrd) {
+	printk("%s: %lld bytes\n", initrd, initrd_st.size);
+	if (load_file(initrd, initrd_st.size, dns323_initrd_segments, INITRD_SLOTS))
+		return -1;
+  }
+
+  /* */
+  dns323_machtype = machtype;
+  printk("dns323_machtype = %ld\n", dns323_machtype);
+  dns323_taglist = virt_to_phys(make_taglist(*initrd ? initrd_st.size : 0));
+  printk("dns323_taglist  = %lx (%p)\n", dns323_taglist, phys_to_virt(dns323_taglist));
+  if (!(dns323_reboot_code = kmalloc(dns323_reboot_size, GFP_KERNEL))) 
+	return dns323_fail("reboot code: Out of memory\n");
+  printk("copying %lu bytes reboot code from %p to %p\n",
+		 dns323_reboot_size, dns323_do_reboot, dns323_reboot_code);
+  memcpy(dns323_reboot_code, dns323_do_reboot, dns323_reboot_size);
+  dns323_reboot_start = virt_to_phys(dns323_reboot_code);
+  printk("dns323_reboot_start  = %lx\n", dns323_reboot_start);
+  
+  /* go. This is a no return point */
+  printk(KERN_INFO "Reloading...\n");
+  flush_icache_range((unsigned long)dns323_reboot_code, (unsigned long)dns323_reboot_code + dns323_reboot_size);
+  cpu_proc_fin();
+  setup_mm_for_reboot(0);
+  dns323_reboot();
 
-        panic("FAILED\n");
-        return 0;
+  panic("FAILED\n");
+  return 0;
 }
 
 static void __exit reloaded_cleanup(void)
 {
-        printk("reloaded: bye\n");
+  printk("reloaded: bye\n");
 }
 
 module_init(reloaded_init);
