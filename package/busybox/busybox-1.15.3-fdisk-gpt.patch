diff -ruN busybox-1.15.3-orig/include/libbb.h busybox-1.15.3/include/libbb.h
--- busybox-1.15.3-orig/include/libbb.h	2009-12-12 21:13:28.000000000 +0000
+++ busybox-1.15.3/include/libbb.h	2011-06-01 02:01:32.161952610 +0100
@@ -686,7 +686,7 @@
 char *utoa_to_buf(unsigned n, char *buf, unsigned buflen) FAST_FUNC;
 char *itoa_to_buf(int n, char *buf, unsigned buflen) FAST_FUNC;
 /* Intelligent formatters of bignums */
-void smart_ulltoa4(unsigned long long ul, char buf[5], const char *scale) FAST_FUNC;
+void smart_ulltoa4(unsigned long long ul, char buf[4], const char *scale) FAST_FUNC;
 void smart_ulltoa5(unsigned long long ul, char buf[5], const char *scale) FAST_FUNC;
 //TODO: provide pointer to buf (avoid statics)?
 const char *make_human_readable_str(unsigned long long size,
@@ -1415,7 +1415,10 @@
 void md5_hash(const void *data, size_t length, md5_ctx_t *ctx) FAST_FUNC;
 void md5_end(void *resbuf, md5_ctx_t *ctx) FAST_FUNC;
 
-
+/* TODO: add global crc32_table pointer and create  
+ * LE and BE functions to calculate crc32 over given bytes.
+ * Currently we have about five reimplementations...
+ */
 uint32_t *crc32_filltable(uint32_t *tbl256, int endian) FAST_FUNC;
 
 typedef struct masks_labels_t {
diff -ruN busybox-1.15.3-orig/libbb/xfuncs.c busybox-1.15.3/libbb/xfuncs.c
--- busybox-1.15.3-orig/libbb/xfuncs.c	2009-12-12 21:13:28.000000000 +0000
+++ busybox-1.15.3/libbb/xfuncs.c	2011-06-01 02:01:36.387141202 +0100
@@ -51,7 +51,7 @@
 /* Convert unsigned long long value into compact 4-char
  * representation. Examples: "1234", "1.2k", " 27M", "123T"
  * String is not terminated (buf[4] is untouched) */
-void FAST_FUNC smart_ulltoa4(unsigned long long ul, char buf[5], const char *scale)
+void FAST_FUNC smart_ulltoa4(unsigned long long ul, char buf[4], const char *scale)
 {
 	const char *fmt;
 	char c;
@@ -99,7 +99,7 @@
 
 /* Convert unsigned long long value into compact 5-char representation.
  * String is not terminated (buf[5] is untouched) */
-void FAST_FUNC smart_ulltoa5(unsigned long long ul, char buf[6], const char *scale)
+void FAST_FUNC smart_ulltoa5(unsigned long long ul, char buf[5], const char *scale)
 {
 	const char *fmt;
 	char c;
diff -ruN busybox-1.15.3-orig/util-linux/Config.in busybox-1.15.3/util-linux/Config.in
--- busybox-1.15.3-orig/util-linux/Config.in	2009-12-12 21:13:29.000000000 +0000
+++ busybox-1.15.3/util-linux/Config.in	2011-06-01 02:01:39.603277250 +0100
@@ -172,6 +172,14 @@
 	  Enabling this option allows you to create or change BSD disklabels
 	  and define and edit BSD disk slices.
 
+config FEATURE_GPT_LABEL
+	bool "Support GPT disklabels"
+	default n
+	depends on FDISK && FEATURE_FDISK_WRITABLE
+	help
+	  Enabling this option allows you to view GUID Partition Table
+	  disklabels.
+
 config FEATURE_FDISK_ADVANCED
 	bool "Support expert mode"
 	default n
diff -ruN busybox-1.15.3-orig/util-linux/fdisk.c busybox-1.15.3/util-linux/fdisk.c
--- busybox-1.15.3-orig/util-linux/fdisk.c	2009-12-12 21:13:29.000000000 +0000
+++ busybox-1.15.3/util-linux/fdisk.c	2011-06-01 02:01:42.596398093 +0100
@@ -90,12 +90,30 @@
 	unsigned char size4[4];         /* nr of sectors in partition */
 } PACKED;
 
+/*
+ * per partition table entry data
+ *
+ * The four primary partitions have the same sectorbuffer (MBRbuffer)
+ * and have NULL ext_pointer.
+ * Each logical partition table entry has two pointers, one for the
+ * partition and one link to the next one.
+ */
+struct pte {
+	struct partition *part_table;   /* points into sectorbuffer */
+	struct partition *ext_pointer;  /* points into sectorbuffer */
+	ullong offset; /* disk sector number */
+	char *sectorbuffer;             /* disk sector contents */
+#if ENABLE_FEATURE_FDISK_WRITABLE
+	char changed;                   /* boolean */
+#endif
+};
+
 static const char unable_to_open[] ALIGN1 = "can't open '%s'";
 static const char unable_to_read[] ALIGN1 = "can't read from %s";
 static const char unable_to_seek[] ALIGN1 = "can't seek on %s";
 
 enum label_type {
-	LABEL_DOS, LABEL_SUN, LABEL_SGI, LABEL_AIX, LABEL_OSF
+	LABEL_DOS, LABEL_SUN, LABEL_SGI, LABEL_AIX, LABEL_OSF, LABEL_GPT
 };
 
 #define LABEL_IS_DOS	(LABEL_DOS == current_label_type)
@@ -132,6 +150,14 @@
 #define STATIC_OSF extern
 #endif
 
+#if ENABLE_FEATURE_GPT_LABEL
+#define LABEL_IS_GPT	(LABEL_GPT == current_label_type)
+#define STATIC_GPT static
+#else
+#define LABEL_IS_GPT	0
+#define STATIC_GPT extern
+#endif
+
 enum action { OPEN_MAIN, TRY_ONLY, CREATE_EMPTY_DOS, CREATE_EMPTY_SUN };
 
 static void update_units(void);
@@ -145,6 +171,7 @@
 #endif
 static const char *partition_type(unsigned char type);
 static void get_geometry(void);
+static void read_pte(struct pte *pe, ullong offset);
 #if ENABLE_FEATURE_SUN_LABEL || ENABLE_FEATURE_FDISK_WRITABLE
 static int get_boot(enum action what);
 #else
@@ -157,24 +184,6 @@
 static unsigned get_start_sect(const struct partition *p);
 static unsigned get_nr_sects(const struct partition *p);
 
-/*
- * per partition table entry data
- *
- * The four primary partitions have the same sectorbuffer (MBRbuffer)
- * and have NULL ext_pointer.
- * Each logical partition table entry has two pointers, one for the
- * partition and one link to the next one.
- */
-struct pte {
-	struct partition *part_table;   /* points into sectorbuffer */
-	struct partition *ext_pointer;  /* points into sectorbuffer */
-	ullong offset;          /* disk sector number */
-	char *sectorbuffer;     /* disk sector contents */
-#if ENABLE_FEATURE_FDISK_WRITABLE
-	char changed;           /* boolean */
-#endif
-};
-
 /* DOS partition types */
 
 static const char *const i386_sys_types[] = {
@@ -628,6 +637,8 @@
 STATIC_OSF void xbsd_print_disklabel(int);
 #include "fdisk_osf.c"
 
+#include "fdisk_gpt.c"
+
 #if ENABLE_FEATURE_SGI_LABEL || ENABLE_FEATURE_SUN_LABEL
 static uint16_t
 fdisk_swap16(uint16_t x)
@@ -812,6 +823,11 @@
 		puts("o\tcreate a new empty DOS partition table");
 		puts("q\tquit without saving changes");
 		puts("s\tcreate a new empty Sun disklabel");  /* sun */
+	} else if (LABEL_IS_GPT) {
+		puts("o\tcreate a new empty DOS partition table");
+		puts("p\tprint the partition table");
+		puts("q\tquit without saving changes");
+		puts("s\tcreate a new empty Sun disklabel");  /* sun */
 	} else {
 		puts("a\ttoggle a bootable flag");
 		puts("b\tedit bsd disklabel");
@@ -1275,7 +1291,18 @@
 
 /*
  * Opens disk_device and optionally reads MBR.
- *    FIXME: document what each 'what' value will do!
+ *    If what == OPEN_MAIN:
+ *      Open device, read MBR.  Abort program on short read.  Create empty
+ *      disklabel if the on-disk structure is invalid (WRITABLE mode).
+ *    If what == TRY_ONLY:
+ *      Open device, read MBR.  Return an error if anything is out of place.
+ *      Do not create an empty disklabel.  This is used for the "list"
+ *      operations: "fdisk -l /dev/sda" and "fdisk -l" (all devices).
+ *    If what == CREATE_EMPTY_*:
+ *      This means that get_boot() was called recursively from create_*label().
+ *      Do not re-open the device; just set up the ptes array and print
+ *      geometry warnings.
+ *
  * Returns:
  *   -1: no 0xaa55 flag present (possibly entire disk BSD)
  *    0: found or created label
@@ -1357,6 +1384,10 @@
 	if (check_aix_label())
 		return 0;
 #endif
+#if ENABLE_FEATURE_GPT_LABEL
+	if (check_gpt_label())
+		return 0;
+#endif
 #if ENABLE_FEATURE_OSF_LABEL
 	if (check_osf_label()) {
 		possibly_osf_label = 1;
@@ -1376,7 +1407,7 @@
 	if (!valid_part_table_flag(MBRbuffer)) {
 		if (what == OPEN_MAIN) {
 			printf("Device contains neither a valid DOS "
-				  "partition table, nor Sun, SGI or OSF "
+				  "partition table, nor Sun, SGI, OSF or GPT "
 				  "disklabel\n");
 #ifdef __sparc__
 			IF_FEATURE_SUN_LABEL(create_sunlabel();)
@@ -2021,10 +2052,14 @@
 		sun_list_table(xtra);
 		return;
 	}
-	if (LABEL_IS_SUN) {
+	if (LABEL_IS_SGI) {
 		sgi_list_table(xtra);
 		return;
 	}
+	if (LABEL_IS_GPT) {
+		gpt_list_table(xtra);
+		return;
+	}
 
 	list_disk_geometry();
 
diff -ruN busybox-1.15.3-orig/util-linux/fdisk_gpt.c busybox-1.15.3/util-linux/fdisk_gpt.c
--- busybox-1.15.3-orig/util-linux/fdisk_gpt.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.15.3/util-linux/fdisk_gpt.c	2011-06-01 02:01:45.667516379 +0100
@@ -0,0 +1,220 @@
+#if ENABLE_FEATURE_GPT_LABEL
+/*
+ * Copyright (C) 2010 Kevin Cernekee <cernekee@gmail.com>
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+
+#define GPT_MAGIC 0x5452415020494645ULL
+enum {
+	LEGACY_GPT_TYPE	= 0xee,
+	GPT_MAX_PARTS   = 256,
+	GPT_MAX_PART_ENTRY_LEN = 4096,
+	GUID_LEN        = 16,
+};
+
+typedef struct {
+	uint64_t magic;
+	uint32_t revision;
+	uint32_t hdr_size;
+	uint32_t hdr_crc32;
+	uint32_t reserved;
+	uint64_t current_lba;
+	uint64_t backup_lba;
+	uint64_t first_usable_lba;
+	uint64_t last_usable_lba;
+	uint8_t  disk_guid[GUID_LEN];
+	uint64_t first_part_lba;
+	uint32_t n_parts;
+	uint32_t part_entry_len;
+	uint32_t part_array_crc32;
+} gpt_header;
+
+typedef struct {
+	uint8_t  type_guid[GUID_LEN];
+	uint8_t  part_guid[GUID_LEN];
+	uint64_t lba_start;
+	uint64_t lba_end;
+	uint64_t flags;
+	uint16_t name[36];
+} gpt_partition;
+
+static gpt_header *gpt_hdr;
+
+static char *part_array;
+static unsigned int n_parts;
+static unsigned int part_array_len;
+static unsigned int part_entry_len;
+
+static uint32_t *crc32_table;
+
+static inline gpt_partition *
+gpt_part(int i)
+{
+	if (i >= n_parts) {
+		return NULL;
+	}
+	return (gpt_partition *)&part_array[i * part_entry_len];
+}
+
+/* TODO: move to libbb */
+static uint32_t
+gpt_crc32(void *buf, int len)
+{
+	uint32_t crc = 0xffffffff;
+
+	for (; len > 0; len--, buf++) {
+		crc = crc32_table[(crc ^ *((char *)buf)) & 0xff] ^ (crc >> 8);
+	}
+	return crc ^ 0xffffffff;
+}
+
+static void
+gpt_print_guid(uint8_t *buf)
+{
+	printf(
+		"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
+		buf[3], buf[2], buf[1], buf[0],
+		buf[5], buf[4],
+		buf[7], buf[6],
+		buf[8], buf[9],
+		buf[10], buf[11], buf[12], buf[13], buf[14], buf[15]);
+}
+
+/* TODO: real unicode support */
+static void
+gpt_print_wide(uint16_t *s, int max_len)
+{
+	int i = 0;
+
+	while (i < max_len) {
+		if (*s == 0)
+			return;
+		fputc(*s, stdout);
+		s++;
+	}
+}
+
+static unsigned int
+gpt_type(uint8_t type[GUID_LEN]) {
+
+	char buf[GUID_LEN];
+	sprintf(buf, 
+		"%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X",
+		type[3], type[2], type[1], type[0],
+		type[5], type[4],
+		type[7], type[6],
+		type[8], type[9],
+		type[10], type[11], type[12], type[13], type[14], type[15]);
+	if (memcmp(buf, "EBD0A0A2-B9E5-4433-87C0-68B6B72699C7", GUID_LEN) == 0) // Windows data
+		return 0x0700;
+	if (memcmp(buf, "0FC63DAF-8483-4772-8E79-3D69D8477DE4", GUID_LEN) == 0) // Linux filesystem
+		return 0x8300;
+	if (memcmp(buf, "0657FD6D-A4AB-43C4-84E5-0933C84B4F4F", GUID_LEN) == 0) // Linux swap
+		return 0x8200;
+	if (memcmp(buf, "A19D880F-05FC-4D3B-A006-743F0F84911E", GUID_LEN) == 0) // Linux RAID
+		return 0xfd00;
+	if (memcmp(buf, "E6D6D379-F507-44C2-A23C-238F2A3DF928", GUID_LEN) == 0) // Linux LVM
+		return 0x8e00;
+	return 0xffff;
+}
+
+static void
+gpt_list_table(int xtra UNUSED_PARAM)
+{
+	int i;
+	char numstr6[6];
+
+	numstr6[5] = '\0';
+
+	smart_ulltoa5(total_number_of_sectors * sector_size, numstr6, " KMGTPEZY");
+	printf("\nDisk %s: %sB, %llu bytes\n", disk_device, numstr6,
+		(unsigned long long)total_number_of_sectors * sector_size);
+	printf("Found valid GPT with protective MBR; using GPT\n");
+	printf("Disk identifier (GUID): ");
+	gpt_print_guid(gpt_hdr->disk_guid);
+	printf("\nFirst usable sector is %llu, last usable sector is %llu\n\n",
+		(unsigned long long)SWAP_LE64(gpt_hdr->first_usable_lba),
+		(unsigned long long)SWAP_LE64(gpt_hdr->last_usable_lba));
+
+	printf("   Device  Start (sector)    End (sector)  Size (sectors)   Code  Name\n");
+	for (i = 0; i < n_parts; i++) {
+		gpt_partition *p = gpt_part(i);
+		if (p->lba_start) {
+			printf("%s%1u %15llu %15llu %15llu   %04x  ",
+				disk_device, i + 1,
+				(unsigned long long)SWAP_LE64(p->lba_start),
+				(unsigned long long)SWAP_LE64(p->lba_end),
+				1 + SWAP_LE64(p->lba_end) - SWAP_LE64(p->lba_start),
+				gpt_type(p->type_guid));
+			gpt_print_wide(p->name, 18);
+			printf("\n");
+		}
+	}
+}
+
+static int
+check_gpt_label(void)
+{
+	struct partition *first = pt_offset(MBRbuffer, 0);
+	struct pte pe;
+	uint32_t crc;
+
+	/* LBA 0 contains the legacy MBR */
+
+	if (!valid_part_table_flag(MBRbuffer)
+	 || first->sys_ind != LEGACY_GPT_TYPE
+	) {
+		current_label_type = 0;
+		return 0;
+	}
+
+	/* LBA 1 contains the GPT header */
+
+	read_pte(&pe, 1);
+	gpt_hdr = (void *)pe.sectorbuffer;
+
+	if (gpt_hdr->magic != SWAP_LE64(GPT_MAGIC)) {
+		current_label_type = 0;
+		return 0;
+	}
+
+	if (!crc32_table) {
+		crc32_table = crc32_filltable(NULL, 0);
+	}
+
+	crc = SWAP_LE32(gpt_hdr->hdr_crc32);
+	gpt_hdr->hdr_crc32 = 0;
+	if (gpt_crc32(gpt_hdr, SWAP_LE32(gpt_hdr->hdr_size)) != crc) {
+		/* FIXME: read the backup table */
+		puts("\nwarning: GPT header CRC is invalid\n");
+	}
+
+	n_parts = SWAP_LE32(gpt_hdr->n_parts);
+	part_entry_len = SWAP_LE32(gpt_hdr->part_entry_len);
+	if (n_parts > GPT_MAX_PARTS
+	 || part_entry_len > GPT_MAX_PART_ENTRY_LEN
+	 || SWAP_LE32(gpt_hdr->hdr_size) > sector_size
+	) {
+		puts("\nwarning: unable to parse GPT disklabel\n");
+		current_label_type = 0;
+		return 0;
+	}
+
+	part_array_len = n_parts * part_entry_len;
+	part_array = xmalloc(part_array_len);
+	seek_sector(SWAP_LE64(gpt_hdr->first_part_lba));
+	if (full_read(dev_fd, part_array, part_array_len) != part_array_len) {
+		fdisk_fatal(unable_to_read);
+	}
+
+	if (gpt_crc32(part_array, part_array_len) != gpt_hdr->part_array_crc32) {
+		/* FIXME: read the backup table */
+		puts("\nwarning: GPT array CRC is invalid\n");
+	}
+
+	current_label_type = LABEL_GPT;
+	return 1;
+}
+
+#endif /* GPT_LABEL */
